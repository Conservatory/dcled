/* dcled - userland driver for Dream Cheeky (Dream Link?) USB LED Message Board
 * Copyright 2009 Jeff Jahr <malakais@pacbell.net>
 * This is free software.  G'head, use it all you want. 
 * Version 1.0 took ~12 hours to write, and was my first foray into usb
 * device programming.  This is probably not a real good example of how to
 * do ANYTHING.  Sun Jan  4 00:18:41 PST 2009 -jsj
 */

#include <asm/types.h>
#include <fcntl.h>
#include <linux/hiddev.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <getopt.h>

#define VENDOR 0x1d34
#define PRODUCT 0x0013
/* heh heh.  ledsx.  thats almost dirty. */
#define LEDSX 21
#define LEDSY 7

/* This is the usage that gets sent to the device, from the docs supplied by
 * Alvin Wong. */
struct ledpkt {
	unsigned char brightness;
	unsigned char row;
	unsigned char data1[3];
	unsigned char data2[3];
};

/* This is a basic definition of the led display. 0,0 is the upper left. */
struct ledscreen {
	int ledfd;
	int brightness;
	int scrolldelay;
	int scrolldir;
	int led[LEDSX][LEDSY];
};

void clearscreen(int mode,struct ledscreen *disp);
void scroll(int dir, struct ledscreen *disp);
void scrollrndfade(struct ledscreen *disp, int isend, int width);
void scrollpreamble(int which, int isend, struct ledscreen *disp);
void staticwarmup(struct ledscreen *disp, int isend, int width);

int debug = 0;
int echo = 0;
char version[] = "1.0";

/* 
  Copy a font definition into a character pointer.  In this application, fonts
  are 256x7 bytes.
*/
void initfont1 (char *target) {
	
	/* This copies the font data into a pre-allocated array, as someday i hope
	 * to have some other fonts for the display. */

	/* 
	 Font is 7 bytes per entry, each byte is a row.  The character bitmaps are
	 like 5 bits wide, mirrored, starting at bit zero.  Why so bizzare, you
	 ask?  Oh god, the horror of converting from an existing font to this...
	 ImageMagick -draw text, conversion to xbm format, tcl scripts to parse the
	 xbm data into this c code... anyway, it was faster than drawing a font
	 myself, although not by much.  Ulitmately, this array was built
	 automatically from the X11 5x7 font, and it works.  That is what matters
	 for an afternoon project.  Feel free to improve it. :)
	*/

	 
	static char font[256][7] = {
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },
		{ 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x00 },
		{ 0x00, 0x0E, 0x05, 0x0E, 0x14, 0x0E, 0x00 },
		{ 0x01, 0x09, 0x04, 0x02, 0x09, 0x08, 0x00 },
		{ 0x00, 0x02, 0x05, 0x02, 0x05, 0x0A, 0x00 },
		{ 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00 },
		{ 0x04, 0x02, 0x02, 0x02, 0x02, 0x04, 0x00 },
		{ 0x02, 0x04, 0x04, 0x04, 0x04, 0x02, 0x00 },
		{ 0x00, 0x0A, 0x04, 0x0E, 0x04, 0x0A, 0x00 },
		{ 0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x02 },
		{ 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x00 },
		{ 0x00, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00 },
		{ 0x04, 0x0A, 0x0A, 0x0A, 0x0A, 0x04, 0x00 },
		{ 0x04, 0x06, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x06, 0x09, 0x08, 0x04, 0x02, 0x0F, 0x00 },
		{ 0x0F, 0x08, 0x06, 0x08, 0x09, 0x06, 0x00 },
		{ 0x04, 0x06, 0x05, 0x0F, 0x04, 0x04, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x08, 0x09, 0x06, 0x00 },
		{ 0x06, 0x01, 0x07, 0x09, 0x09, 0x06, 0x00 },
		{ 0x0F, 0x08, 0x04, 0x04, 0x02, 0x02, 0x00 },
		{ 0x06, 0x09, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0E, 0x08, 0x06, 0x00 },
		{ 0x00, 0x06, 0x06, 0x00, 0x06, 0x06, 0x00 },
		{ 0x00, 0x06, 0x06, 0x00, 0x06, 0x02, 0x01 },
		{ 0x00, 0x08, 0x04, 0x02, 0x04, 0x08, 0x00 },
		{ 0x00, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00 },
		{ 0x00, 0x02, 0x04, 0x08, 0x04, 0x02, 0x00 },
		{ 0x04, 0x0A, 0x08, 0x04, 0x00, 0x04, 0x00 },
		{ 0x06, 0x09, 0x0D, 0x0D, 0x01, 0x06, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x07, 0x09, 0x07, 0x09, 0x09, 0x07, 0x00 },
		{ 0x06, 0x09, 0x01, 0x01, 0x09, 0x06, 0x00 },
		{ 0x07, 0x09, 0x09, 0x09, 0x09, 0x07, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x01, 0x00 },
		{ 0x06, 0x09, 0x01, 0x0D, 0x09, 0x0E, 0x00 },
		{ 0x09, 0x09, 0x0F, 0x09, 0x09, 0x09, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x08, 0x08, 0x08, 0x08, 0x09, 0x06, 0x00 },
		{ 0x09, 0x05, 0x03, 0x03, 0x05, 0x09, 0x00 },
		{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x09, 0x0F, 0x0F, 0x09, 0x09, 0x09, 0x00 },
		{ 0x09, 0x0B, 0x0B, 0x0D, 0x0D, 0x09, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x07, 0x09, 0x09, 0x07, 0x01, 0x01, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x0B, 0x06, 0x08 },
		{ 0x07, 0x09, 0x09, 0x07, 0x05, 0x09, 0x00 },
		{ 0x06, 0x09, 0x02, 0x04, 0x09, 0x06, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },
		{ 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x09, 0x09, 0x09, 0x09, 0x06, 0x06, 0x00 },
		{ 0x09, 0x09, 0x09, 0x0F, 0x0F, 0x09, 0x00 },
		{ 0x09, 0x09, 0x06, 0x06, 0x09, 0x09, 0x00 },
		{ 0x0A, 0x0A, 0x0A, 0x04, 0x04, 0x04, 0x00 },
		{ 0x0F, 0x08, 0x04, 0x02, 0x01, 0x0F, 0x00 },
		{ 0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x00 },
		{ 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00 },
		{ 0x0E, 0x08, 0x08, 0x08, 0x08, 0x0E, 0x00 },
		{ 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00 },
		{ 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x01, 0x01, 0x07, 0x09, 0x09, 0x07, 0x00 },
		{ 0x00, 0x00, 0x06, 0x01, 0x01, 0x06, 0x00 },
		{ 0x08, 0x08, 0x0E, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x00, 0x00, 0x06, 0x0D, 0x03, 0x06, 0x00 },
		{ 0x04, 0x0A, 0x02, 0x07, 0x02, 0x02, 0x00 },
		{ 0x00, 0x00, 0x0E, 0x09, 0x06, 0x01, 0x0E },
		{ 0x01, 0x01, 0x07, 0x09, 0x09, 0x09, 0x00 },
		{ 0x04, 0x00, 0x06, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x08, 0x00, 0x08, 0x08, 0x08, 0x0A, 0x04 },
		{ 0x01, 0x01, 0x05, 0x03, 0x05, 0x09, 0x00 },
		{ 0x06, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x00, 0x00, 0x05, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x00, 0x00, 0x07, 0x09, 0x09, 0x09, 0x00 },
		{ 0x00, 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x00, 0x00, 0x07, 0x09, 0x09, 0x07, 0x01 },
		{ 0x00, 0x00, 0x0E, 0x09, 0x09, 0x0E, 0x08 },
		{ 0x00, 0x00, 0x07, 0x09, 0x01, 0x01, 0x00 },
		{ 0x00, 0x00, 0x0E, 0x03, 0x0C, 0x07, 0x00 },
		{ 0x02, 0x02, 0x07, 0x02, 0x02, 0x0C, 0x00 },
		{ 0x00, 0x00, 0x09, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0x04, 0x00 },
		{ 0x00, 0x00, 0x09, 0x09, 0x0F, 0x0F, 0x00 },
		{ 0x00, 0x00, 0x09, 0x06, 0x06, 0x09, 0x00 },
		{ 0x00, 0x00, 0x09, 0x09, 0x0A, 0x04, 0x02 },
		{ 0x00, 0x00, 0x0F, 0x04, 0x02, 0x0F, 0x00 },
		{ 0x08, 0x04, 0x06, 0x04, 0x04, 0x08, 0x00 },
		{ 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },
		{ 0x02, 0x04, 0x0C, 0x04, 0x04, 0x02, 0x00 },
		{ 0x0A, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x04, 0x00, 0x04, 0x04, 0x04, 0x04, 0x00 },
		{ 0x00, 0x04, 0x0E, 0x05, 0x05, 0x0E, 0x04 },
		{ 0x00, 0x0C, 0x02, 0x07, 0x02, 0x0D, 0x00 },
		{ 0x00, 0x11, 0x0E, 0x0A, 0x0E, 0x11, 0x00 },
		{ 0x0A, 0x0A, 0x04, 0x0E, 0x04, 0x04, 0x00 },
		{ 0x00, 0x04, 0x04, 0x00, 0x04, 0x04, 0x00 },
		{ 0x0C, 0x02, 0x06, 0x0A, 0x0C, 0x08, 0x06 },
		{ 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x0E, 0x11, 0x15, 0x13, 0x15, 0x11, 0x0E },
		{ 0x06, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x12, 0x09, 0x12, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x0F, 0x08, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00 },
		{ 0x0E, 0x11, 0x17, 0x13, 0x13, 0x11, 0x0E },
		{ 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x04, 0x0A, 0x04, 0x00, 0x00, 0x00, 0x00 },
		{ 0x04, 0x04, 0x1F, 0x04, 0x04, 0x1F, 0x00 },
		{ 0x06, 0x04, 0x02, 0x06, 0x00, 0x00, 0x00 },
		{ 0x06, 0x06, 0x04, 0x06, 0x00, 0x00, 0x00 },
		{ 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x09, 0x09, 0x09, 0x07, 0x01 },
		{ 0x0E, 0x0B, 0x0B, 0x0A, 0x0A, 0x0A, 0x00 },
		{ 0x00, 0x00, 0x06, 0x06, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02 },
		{ 0x04, 0x06, 0x04, 0x0E, 0x00, 0x00, 0x00 },
		{ 0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00 },
		{ 0x00, 0x00, 0x09, 0x12, 0x09, 0x00, 0x00 },
		{ 0x01, 0x01, 0x01, 0x09, 0x0C, 0x0E, 0x08 },
		{ 0x01, 0x01, 0x01, 0x0D, 0x08, 0x04, 0x0C },
		{ 0x03, 0x03, 0x02, 0x0B, 0x0C, 0x0E, 0x08 },
		{ 0x04, 0x00, 0x04, 0x02, 0x0A, 0x04, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x06, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x09, 0x06, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x06, 0x06, 0x09, 0x0F, 0x09, 0x09, 0x00 },
		{ 0x0E, 0x05, 0x0D, 0x07, 0x05, 0x0D, 0x00 },
		{ 0x06, 0x09, 0x01, 0x01, 0x09, 0x06, 0x02 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x0F, 0x01, 0x07, 0x01, 0x01, 0x0F, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x0E, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x07, 0x0A, 0x0B, 0x0A, 0x0A, 0x07, 0x00 },
		{ 0x0D, 0x09, 0x0B, 0x0D, 0x0D, 0x09, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x06, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x09, 0x06, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x00, 0x00, 0x09, 0x06, 0x06, 0x09, 0x00 },
		{ 0x0E, 0x0D, 0x0D, 0x0B, 0x0B, 0x07, 0x00 },
		{ 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x09, 0x00, 0x09, 0x09, 0x09, 0x06, 0x00 },
		{ 0x0A, 0x0A, 0x0A, 0x04, 0x04, 0x04, 0x00 },
		{ 0x01, 0x07, 0x09, 0x07, 0x01, 0x01, 0x00 },
		{ 0x06, 0x09, 0x05, 0x09, 0x09, 0x05, 0x00 },
		{ 0x02, 0x04, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x04, 0x02, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x04, 0x0A, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x0A, 0x05, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x0A, 0x00, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x06, 0x06, 0x0E, 0x09, 0x0D, 0x0A, 0x00 },
		{ 0x00, 0x00, 0x0E, 0x0D, 0x05, 0x0E, 0x00 },
		{ 0x00, 0x00, 0x0C, 0x02, 0x02, 0x0C, 0x04 },
		{ 0x02, 0x04, 0x06, 0x0D, 0x03, 0x06, 0x00 },
		{ 0x04, 0x02, 0x06, 0x0D, 0x03, 0x06, 0x00 },
		{ 0x02, 0x05, 0x06, 0x0D, 0x03, 0x06, 0x00 },
		{ 0x05, 0x00, 0x06, 0x0D, 0x03, 0x06, 0x00 },
		{ 0x02, 0x04, 0x06, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x04, 0x02, 0x06, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x04, 0x0A, 0x06, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x0A, 0x00, 0x06, 0x04, 0x04, 0x0E, 0x00 },
		{ 0x02, 0x0C, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x0A, 0x05, 0x07, 0x09, 0x09, 0x09, 0x00 },
		{ 0x02, 0x04, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x04, 0x02, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x06, 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x0A, 0x05, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x0A, 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 },
		{ 0x00, 0x06, 0x00, 0x0F, 0x00, 0x06, 0x00 },
		{ 0x00, 0x00, 0x0E, 0x0D, 0x0B, 0x07, 0x00 },
		{ 0x02, 0x04, 0x09, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x04, 0x02, 0x09, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x06, 0x00, 0x09, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x0A, 0x00, 0x09, 0x09, 0x09, 0x0E, 0x00 },
		{ 0x04, 0x02, 0x09, 0x09, 0x0A, 0x04, 0x02 },
		{ 0x00, 0x01, 0x07, 0x09, 0x09, 0x07, 0x01 },
		{ 0x0A, 0x00, 0x09, 0x09, 0x0A, 0x04, 0x02 },
	};

	memcpy(target,&font,sizeof(font));

};

/* this is the routine that sends a packet to the display. */
void send_report(int fd, int id, char *buf, int n) {

	struct hiddev_usage_ref_multi uref;
	struct hiddev_report_info rinfo;
	int i;

	uref.uref.report_type = HID_REPORT_TYPE_OUTPUT;
	uref.uref.report_id = id;
	uref.uref.field_index = 0;
	uref.uref.usage_index = 0;
	uref.num_values = n;

	for (i = 0; i < n; ++i) {
		uref.values[i] = buf[i];
	}

	if (ioctl(fd, HIDIOCSUSAGES, &uref) == -1) {
		fprintf(stderr,"send report %02x/%d, HIDIOCSUSAGES: %s",
			id, n, strerror(errno)
		);
	}

	rinfo.report_type = HID_REPORT_TYPE_OUTPUT;
	rinfo.report_id = id;
	rinfo.num_fields = 1;
	if (ioctl(fd, HIDIOCSREPORT, &rinfo) == -1) {
		fprintf(stderr,"send report %02x/%d, HIDIOCSREPORT: %s", 
			id, n, strerror(errno)
		);
	}

	return;
}

/* This sends a copy of the ledscreen to stdout.  Useful as a debug.  */
void print_screen (struct ledscreen *sc) {

	int x,y;
	for (y=0;y<LEDSY;y++) {
		for(x=0;x<LEDSX;x++) {
			if(sc->led[x][y] == 1) {
				printf("O");
			} else {
				printf(".");
			}
		}
		printf("\n");
	};
	printf("\n");

	return;
}


/* This sends the led array in the ledscreen structure to the device.  Call it
 * when you want to update the display.  Seems like the device wants to clear
 * itself after about a second, so you might want to keep calling this to
 * refesh the device.  */
void send_screen (struct ledscreen *sc) {
	
	struct ledpkt pkt;
	int row, col, bytep, bitp;

	if(debug) print_screen(sc);
	
	for(row=0;row<LEDSY;row+=2) {
		pkt.brightness = sc->brightness;
		pkt.row = row;

		for(bytep=0;bytep<=2;bytep++) {
			pkt.data1[bytep] = 0xff;
			pkt.data2[bytep] = 0xff;
		}

		bytep=2;
		bitp=0;

		for(col=0;col<LEDSX;col++) {
			if (sc->led[col][row] == 1) {
				pkt.data1[bytep] &= ~(1<<bitp);
			}
			if (sc->led[col][row+1] == 1) {
				pkt.data2[bytep] &= ~(1<<bitp);
			}
			bitp++;
			if(bitp==8) {
				bitp=0;
				bytep--;
			}
		}
		send_report(sc->ledfd,0,(char*)&pkt,sizeof(struct ledpkt));
	}

}

/* clears the screen either by flasing it to zeros, or by scrolling it away.*/
void clearscreen(int mode,struct ledscreen *disp) {
	int x,y;
	switch (mode) {
		case 1: /* west scroll */
			for(x=0;x<=LEDSX;x++) {
				send_screen(disp);
				usleep(disp->scrolldelay);
				scroll(3,disp);
			}
		break;
		default:
		case 0: /* clear */
			for (x=0;x<LEDSX;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = 0;
				}
			}
			break;
		break;
	}
	return;
}

/* try and open the hiddevice.  The vendor and product have to be right!*/
int open_dev(char *path) {
	char buf[1024];
	int i, fd;
	struct hiddev_devinfo dinfo;

	fd = open(path, O_RDWR);
	if (fd >= 0) {
		if (ioctl(fd, HIDIOCGDEVINFO, &dinfo) == 0) {
			if (dinfo.vendor == (short)VENDOR && 
				dinfo.product == (short)PRODUCT) {
				return fd;
			}
		}
		close(fd);
	}
	return -1;
}


/* shift the disp one pixel in the given direction.*/
/* not all directions are implemented yet.*/
void scroll(int dir, struct ledscreen *disp) {

	int x,y;

	switch (dir) {
		case 0: /* north - up */
		case 1: /* east - right */
		case 2: /* south - down */
		case 3: /* west - left */
		default:
			for(x=0;x<LEDSX-1;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = disp->led[x+1][y];
				}
			}
			for(y=0;y<LEDSY;y++) {
				disp->led[LEDSX-1][y] = 0;
			}
		}

	return;
}



/* overlay a character onto the display with the leftmost edge of the char
 * starting at xloc.  */
void printchar(struct ledscreen *disp, char *font, char c, int xloc) {

	int cx,cy,x,y;

	for(y=0;y<LEDSY;y++) {
		for (cx=0,x=xloc;x<LEDSX && cx<=5;cx++,x++) {
			disp->led[x][y] = ((*(font+(c*7)+y) & (1<<cx))!=0)?1:disp->led[x][y];
		}
	}
}

/* Prints a test pattern to the screen.  pattern 0 and 1 are the all-on
 * and all-off patterns, which are pretty useful. */
void testpatern (int which, struct ledscreen *disp) {
	
	int x, y;
	char font[256*7];


	switch(which) {
		case 0: /* all off */
			for (x=0;x<LEDSX;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = 0;
				}
			}
			break;
		case 1: /* all on */
			for (x=0;x<LEDSX;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = 1;
				}
			}
			break;
		case 2: /* box borders */
			for(x=0;x<LEDSX;x++) {
				disp->led[x][0] = 1;
				disp->led[x][LEDSY-1] = 1;
			}
			for(y=0;y<LEDSY;y++) {
				disp->led[0][y] = 1;
				disp->led[LEDSX-1][y] = 1;
			}
			break;
		case 3: /* box corners */
			disp->led[0][0] = 1;
			disp->led[LEDSX-1][0] = 1;
			disp->led[LEDSX-1][LEDSY-1] = 1;
			disp->led[0][LEDSY-1] = 1;
			break;
		case 4: /* simple diag */
			for(x=0,y=0;x<LEDSX && y<LEDSY;x++, y++) {
				disp->led[x][y] = 1;
			}
			break;
		case 5: /* random */
			for (x=0;x<LEDSX;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = (rand()>=(RAND_MAX/2))?1:0;
				}
			}
			break;
		case 6: /* Jeff */
			initfont1(font);
			printchar(disp,font,'J',0);
			printchar(disp,font,'e',4);
			printchar(disp,font,'f',8);
			printchar(disp,font,'f',12);
			printchar(disp,font,'!',16);
			break;
	}
	return;
}

/* scrolls random data.  kinda cool, used during development. */
void scrolltest(struct ledscreen *disp) {

	int x,y;
	clearscreen(0,disp);

	while(1) {
		for(y=0;y<LEDSY;y++) {
			disp->led[LEDSX-1][y] = (rand()<(RAND_MAX/3))?1:0;
		}

		send_screen(disp);
		usleep(disp->scrolldelay);

		scroll(3,disp);
	}
}

/* call the right graphic header depending on style and direction. */
void scrollpreamble(int which, int isend, struct ledscreen *disp) {

	switch (which) {
		case 2: 
			staticwarmup(disp,isend,5*LEDSX);
			return;
		case 1: 
			scrollrndfade(disp,isend,3*LEDSX);
			return;
		case 0:
		default:
			if (isend) {
				clearscreen(1,disp);
			}
			return;
	}

}

/* make the display warm up with static, like an old tv. */
void staticwarmup(struct ledscreen *disp, int isend, int width) {

	int count, origbright;
	int x,y;

	
	if (!isend) {
		origbright = disp->brightness;

		for (count=0;count<width;count++) {
			for (x=0;x<LEDSX;x++) {
				for(y=0;y<LEDSY;y++) {
					disp->led[x][y] = 
						(1.8*(float)rand()*width/(float)(RAND_MAX)<count)?1:0;
					disp->brightness = 
						(int)(3.0*(((float)count/(float)width)+0.3*(float)rand()/(float)(RAND_MAX)));
				}
			}
			send_screen(disp);
		}
		disp->brightness = origbright;
		clearscreen(0,disp);
		send_screen(disp);
		usleep(disp->scrolldelay * 5);
	} else {
		clearscreen(1,disp);
	}

}
			
/* A random banner */
void scrollrndfade(struct ledscreen *disp, int isend, int width) {

	int x,y;
	int odds;

	if (!isend) {
		for(odds=0;odds<width;odds++){
			for(y=0;y<LEDSY;y++) {
				disp->led[LEDSX-1][y] = 
					(1.8*(float)rand()*width/(float)(RAND_MAX)<odds)?1:0;
			}

			send_screen(disp);
			usleep(disp->scrolldelay);
			scroll(3,disp);
		}
		scroll(3,disp);
		scroll(3,disp);
	} else {
		scroll(3,disp);
		scroll(3,disp);
		for(odds=width;odds>0;odds--){
			for(y=0;y<LEDSY;y++) {
				disp->led[LEDSX-1][y] = 
					(1.8*(float)rand()*width/(float)(RAND_MAX)<odds)?1:0;
			}

			send_screen(disp);
			usleep(disp->scrolldelay);
			scroll(3,disp);
		}
		clearscreen(1,disp);
	}
}


/* Runs a bunch of test patterns.  */
void fancytest(struct ledscreen *disp) {
	int count, tp, b;
	for (count=0;count<3;count++){
		for (tp=1;tp<=6;tp++) {
			testpatern(0,disp);
			testpatern(tp,disp);
			for (b=0;b<=2;b++) {
				disp->brightness = b;
				send_screen(disp);
				usleep(disp->scrolldelay);
			}
		}
	}
	testpatern(0,disp);
}

/* scroll a character onto the display.  Not all directions are implemented
 * yet.*/
void scrollchar(struct ledscreen *disp, char *font, char ch) {

	int w;

	/* if you start w at 1 instead of zero, the default letters have no space
	 * betwen them.  Kinda cool, think about adding it as an option. */

	for (w=0;w<=4;w++) {
		scroll(3,disp);
		printchar(disp,font,ch,LEDSX-w);
		send_screen(disp);
		usleep(disp->scrolldelay);
	}
	if(echo){
		fputc(ch,stdout);
		fflush(stdout);
	}
}

/* char by char, scroll a string onto the screen.  This is pretty much what
 * we're here for, isn't it? */
void scrollmsg(struct ledscreen *disp, char *font, char* buf) {
	
	char *p;

	p=buf;

	while(*p){
		scrollchar(disp,font,*p++);
	}

	return;
}
	

/* Same thing, bigger scope.  Scroll a whole file. */
void scrollfile(struct ledscreen *disp, char *font, FILE* cin) {
	
	char buf[8192];
	char *nl;
	
	while(fgets(buf,8192,cin)) {
		scrollmsg(disp,font,buf);
	}

}

/* yah, its main allright. */
int main (int argc, char **argv) {

	char devname[1024] = "";
	int x, y, b, tp;
	struct ledscreen maindisp;
	struct ledscreen *disp;
	struct hiddev_devinfo devinfo;
	char fontbuf[256*7];
	char *font;
	int getoptc, option_index = 0;
	int brightness = 2;
	int speed = 0;
	char *msg = NULL;
	int test=0;
	int repeat=0;
	int fileidx=0;
	FILE *cin;
	int devno;
	int preamble=0;

	static struct option long_options[] = {
		{ "brightness",	optional_argument,	0, 'b' },
		{ "debug",	no_argument,	0, 'd' },
		{ "echo",	no_argument,	0, 'e' },
		{ "help",	no_argument,	0, 'h' },
		{ "message",	optional_argument,	0, 'm' },
		{ "outdev",	optional_argument,	0, 'o' },
		{ "repeat",	no_argument,	0, 'r' },
		{ "speed",	optional_argument,	0, 's' },
		{ "test",	no_argument,	0, 't' },
		{ 0,0,0,0 }
	};


	while (1) {
		getoptc = getopt_long (argc, argv, "ho:m:b:s:p:dtre", 
			long_options, &option_index
		);

		if (getoptc == -1) break;

		switch (getoptc) {
			case 'h':
				/* bah getopt sucks.  Why do i have to format this?*/
				/* maybe i just dont know the right way...*/
				fprintf(stdout,"Usage- %s [opts] [files]\n",argv[0]);
				fprintf(stdout,"\t--brightness,-b - how bright, 0-2\n");
				fprintf(stdout,"\t--debug,-d      - mostly useless\n");
				fprintf(stdout,"\t--echo,-e       - send copy to stdout\n");
				fprintf(stdout,"\t--help,-h       - duh\n");
				fprintf(stdout,"\t--message,-m    - a single line to scroll\n");
				fprintf(stdout,"\t--outdev,-o     - specifiy the exact path to the hiddev\n");
				fprintf(stdout,"\t--preamble,-p   - send a graphic before the text.\n");
				fprintf(stdout,"\t--repeat,-r     - keep scrolling forever\n");
				fprintf(stdout,"\t--speed,-s      - ms to delay\n");
				fprintf(stdout,"\t--test,-t       - output a test pattern\n");
				exit(0);
				break;
			case 'o':
				strcpy(devname,optarg);
				break;
			case 'b':
				if (optarg != NULL) {
					brightness = atoi(optarg);
				}
				if (brightness < 0 || brightness > 2) {
					fprintf(stderr,"Brightness must be between 0 and 2.\n");
					exit(1);
				}
				break;
			case 's':
				if (optarg != NULL) {
					speed = atof(optarg) * 1000;
				}
				if (speed < 0 ) {
					fprintf(stderr,"Speed has to be a positive delay.\n");
					exit(1);
				}
				break;
			case 'p':
				if (optarg != NULL) {
					preamble = atoi(optarg);
				}
				break;
			case 'm':
				if (optarg != NULL) {
					msg = strdup(optarg);
				}
				break;
			case 't':
				test = 1;
				break;
			case 'd':
				debug = 1;
				break;
			case 'r':
				repeat = 1;
				break;
			case 'e':
				echo = 1;
				break;
			default:
				abort();
		}
	}

	font = fontbuf;
	initfont1(font);

	srand(getpid());

	disp = &maindisp;
	if ( *devname != '\0' ) {
		if ((disp->ledfd = open_dev(devname)) == -1) {
			fprintf(stderr,"Couldnt open device %s.\n",devname);
			exit(1);
		}
	} else {
		/* Its got to be one of the hiddevs, so go looking.*/
		/* This can't be the right way to search for a device... */
		for(devno=0;devno<32;devno++) {
			sprintf(devname,"/dev/usb/hiddev%d",devno);
			if ((disp->ledfd = open_dev(devname)) != -1) {
				break;
			}
		}
		if(disp->ledfd == -1) {
			fprintf(stderr,"Couldn't find the device.  Was expecting to find a readable\n/dev/usb/hiddev* that matched vendor %0x and product %0x.  Is the\ndevice plugged in? Do you have permission?\n",VENDOR,PRODUCT);
			exit(1);
		}
	}

	disp->brightness = brightness;
	disp->scrolldelay = speed;
	disp->scrolldir = 3;

	/* clears the display */
	clearscreen(0,disp);

	if(test) {
		fprintf(stdout,"Version is %s\n",version);
		fprintf(stdout,"devname is %s\n",devname);
		fprintf(stdout,"brightness is %d\n",brightness);
		fprintf(stdout,"debug is %d\n",debug);
		disp->scrolldelay = 100000;
		fancytest(disp);
		exit(0);
	}

	/* if there is a message, print it and dont bother with files. */
	if(msg != NULL) {
		do {
			scrollpreamble(preamble,0,disp);
			scrollmsg(disp,font,msg);
			scrollpreamble(preamble,1,disp);
		} while (repeat);
		exit(0);
	}

	/* if there are files, print them and dont bother with stdin. */
	if(optind < argc) {
		do {
			fileidx = optind;
			while (fileidx < argc) {
				if ( (cin = fopen(argv[fileidx],"r")) == NULL ) {
					fprintf(stderr,"Couldnt open %s: %s\n", 
						argv[fileidx], strerror(errno)
					);
					exit(0);
				}
				scrollpreamble(preamble,0,disp);
				scrollfile(disp,font,cin);
				scrollpreamble(preamble,1,disp);
				fclose(cin);
				fileidx++;
			}
		} while (repeat);
		exit(0);
	}

	/* read from stdin. */
	scrollpreamble(preamble,0,disp);
	scrollfile(disp,font,stdin);
	scrollpreamble(preamble,1,disp);

}
